class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp=[0]*(n+1)
        dp[0]=1
        for i in range(1,n+1):
            for j in range(i):
                dp[i]+=dp[j]*dp[i-1-j]
        return dp[n]
		
先考虑只有一个节点的情形，设此时的形态有f(1)种，那么很明显f(1)=1

如果有两个节点呢？我们很自然想到，应该在f(1)的基础上考虑递推关系。那么，如果固定一个节点后，有两种情况，一是左子树还剩一个节点，此刻类型数量为f(1)，第二种情况是右子树生一个节点，此刻类型数量为f(1)，固有f(2) = f(1) + f(1)

如果有三个节点呢？我们需要考虑固定两个节点的情况么？当然不行，为什么？

因为当节点数量大于等于2时，无论你如何固定，其形态必然有多种，而在这多种基础之上你如何安排后续剩下的节点呢？所以必须挑出这个误区。

回到二叉树的定义，二叉树本质上就是一个递归的形式，左子树，右子树，根节点。所以根节点应该不变，需要递归处理的是左右子树。

也就是说，还是考虑固定一个节点，即根节点。好的，按照这个思路，还剩2个节点，那么左右子树的分布情况为0+2，1+1，2+0。

所以有3个节点时，递归形式为f(3)=f(2) + f(1)*f(1) + f(2). (注意这里的乘法，因为左右子树一起组成整棵树，根据排列组合里面的乘法原理即可得出)

那么有n个节点呢？我们固定一个节点，那么左右子树的分布情况为n-1=n-1 + 0 = n-2 + 1 = ... = 1 + n-2 = 0 + n-1

OK。递归表达式出来了f(n) = f(n-1) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(n-1)

 

观察一下这个表达式，嗯，和我们之前见过的递归表达有一点区别，递推层级为n的时候，更多的是考虑前一步(n-1)，或者前两步(n-1)和(n-2)。

但是这里却考虑到所有的情况，即1到n-1。

最后说明一下，这个表达式有一个学名，叫做Catalan数。上面我们没有定义f(0)。如果把f(0)也考虑进去，显然没有节点也只有一种情况，即f(0)=1

标准表达式为f(n) = f(n-1)f(0) + f(n-2)f(1) + f(n-3)f(2) + ... + f(1)f(n-2) + f(n-1)f(0)

前几个数为1,1,2,5,14,42,132。

此外，还有一个通项公式为1/(n+1) * C(n, 2n) = C(n, 2n) - C(n-1, 2n) , n = 0,1,2,...